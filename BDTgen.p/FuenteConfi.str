/* $STR: strFuenteConfi */
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <malloc.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <fcntl.h>
#include <string.h>
#include <memory.h>
#include <tpc.h>
#include <err.h>
#include <buf.h>
#include <[-].h>
 
/*--------------------------------------------------------------------
 | PF_COMPAR: punt. a funcion comparac. para "qsort" y "BuscaElemento"
 +--------------------------------------------------------------------*/
typedef int (*PF_COMPAR)(const void *, const void *);

/*--------------------------------------------------------------------
 | FUNC_BDT: nombre de la funcion para los errores.
 +--------------------------------------------------------------------*/
#define FUNC_BDT	"<BAS:nombre>"
 
/*--------------------------------------------------------------------
 | CMP_VAL: compara valores simples, resultado: 1 mayor, 0 igual -1 menor
 | POS_MEM: posicion en la memoria correspondiente a una direccion.
 | DIR_MEM: direccion de la memoria correspondiente a una posicion.
 +--------------------------------------------------------------------*/
#define CMP_VAL(v1, v2)		((v1 == v2)? 0 : (((v1 < v2)? -1 : 1)))
#define POS_MEM(punt)		((char *)(punt) - pMemoria)
#define DIR_MEM(desp)		(pMemoria + (desp))

/*--------------------------------------------------------------------
 | macros para el manejo del estado de los elementos (codificados) de
 | una tabla:
 |      PONER_LIBRE:   pone un elemento como LIBRE.
 |      PONER_OCUPADO: pone un elemento como OCUPADO.
 |      ESTA_LIBRE:    dice si un elemento como LIBRE.
 |      ESTA_OCUPADO:  dice si un elemento como OCUPADO .
 +--------------------------------------------------------------------*/
#define PONER_LIBRE(pE)		pE[0] = 'L'
#define PONER_OCUPADO(pE)	pE[0] = 'O'
#define ESTA_LIBRE(pE)		(pE[0] == 'L')
#define ESTA_OCUPADO(pE)	(pE[0] == 'O')

[TABLA>
/*--------------------------------------------------------------------
 | TAM_<TBL:NOMBRE>: tamano de la struct Type<TBL:NOMBRE>
 | IND_<TBL:NOMBRE>: indice de un elemento segun una posicion en memoria.
 |
 | LON_<TBL:NOMBRE>: longitud del elemento <TBL:NOMBRE> en el fichero
 | POS_<TBL:NOMBRE>: posicion de <TBL:NOMBRE> en el fichero
 | BUF_<TBL:NOMBRE>: tamano de <TBL:NOMBRE> en el fichero.
 | ELE_<TBL:NOMBRE>: posicion de un elemento en el fichero segun el indice
 +--------------------------------------------------------------------*/
#define TAM_<TBL:NOMBRE>	(sizeof(Type<TBL:NOMBRE>))
#define IND_<TBL:NOMBRE>(pos)	((pos - *pPos<TBL:Nombre>) / TAM_<TBL:NOMBRE>)

#define LON_<TBL:NOMBRE>	<TBL:lonEle>
#define POS_<TBL:NOMBRE>	<TBL:posEle>
#define BUF_<TBL:NOMBRE>	(MAX_<TBL:NOMBRE> * LON_<TBL:NOMBRE>)
#define ELE_<TBL:NOMBRE>(i)	(int)(POS_<TBL:NOMBRE>+(LON_<TBL:NOMBRE>*i))
<TABLA]

/*--------------------------------------------------------------------
 | numSEMAF:   numero de semaforos para el acceso a Configuracion.
 | SEMAF_LECT: indice del semaforo de acceso para lectura.
 | SEMAF_ESCR: indice del semaforo de acceso para escritura.
 | ID_BDS:     identificador para la clave de M. Compartida y Semaforos.
 | DMC_ERR:    direccion de M. Compartida erronea.
 +--------------------------------------------------------------------*/
#define numSEMAF	2
#define SEMAF_LECT	0
#define SEMAF_ESCR	1
#define ID_BDS		'B'
#define DMC_ERR		((char *)-1)
 
#ifndef SEMUN
typedef union {
	int               val;
	struct semid_ds * buf;
	unsigned short  * array;
	} SEMUN;
#endif
 
/*====================================================================
 *		FUNCIONES DE ACCESO A REGION CRITICA
 *====================================================================*/
static void AccLectura();
static void SalLectura();
static void AccEscritura();
static void SalEscritura();

/*====================================================================
 *		FUNCIONES DE INICIALIZACION DE LA BASE
 *====================================================================*/
static void CalcularMemoria();
static void IniPunteros(int);
static void IniInformacion();
[TABLA>

/*====================================================================
 *	FUNCIONES DE TRATAMIENTO DE LA TABLA <TBL:NOMBRE>
 *====================================================================*/
static void Ord<TBL:Nombre>();
static int *Clave<TBL:Nombre>(const int);
[CLAVE>
static int  Cmp<CLA:Nombre><TBL:Nombre>(const Type<TBL:NOMBRE> *,
				const Type<TBL:NOMBRE> *);
static int  CmpDes<CLA:Nombre><TBL:Nombre>(const int *, const int *); 
<CLAVE]
<TABLA]

/*====================================================================
 *		FUNCIONES GENERALES A LA BASE
 *====================================================================*/
static int  AnaIntegridadOperacion(char, int, void *);
static void CalcSumaResta(char *, int, int, int *, int *);
static int  BuscaElemento(void *, int *, int, PF_COMPAR);
static void PosicionLibre(int, int *, int);

/*====================================================================
 *		 VARIABLES LOCALES DE LA BASE <BAS:nombre>
 *====================================================================*/
/*--------------------------------------------------------------------
 | fichImagen:	fichero imagen de la Configuracion
 | fdFBD:	descriptor del fichero de Configuracion
 | pMemoria:	memoria (compartida o dinamica) para la Configuracion.
 | tamMemoria:	tamano de la memoria en bytes para la Configuracion.
 +--------------------------------------------------------------------*/
static char *fichImagen  = "[+].ibd";
static int   fdFBD	 = -1;
static char *pMemoria	 = NULL;
static int   lonMemoria	 = 0;

/*--------------------------------------------------------------------
 | identSem: identificador de los semaforos de acceso.
 | identMC: identificador de la memoria compartida.
 | basePrivada: indica si la base se ha creado como privada o compartida.
 | vectorSig: vector de senales para el bloque y desbloqueo de estas.
 +--------------------------------------------------------------------*/
static int   identSem	 = -1;
static int   identMC	 = -1;
static int   basePrivada = 0;
static sigset_t vectorSig;

[TABLA>
/*--------------------------------------------------------------------
 | Variables asociadas a la tabla <TBL:NOMBRE>:
 |	pPos<TBL:Nombre>: punt. a la posicion de los elementos.
 |	pNum<TBL:Nombre>: punt. al numero de elementos.
 |	pMax<TBL:Nombre>: punt. al numero maximo de elementos.
 |	pSum<TBL:Nombre>: punt. al resultado suma de la tabla (ckeck-sum)
 |	pSes<TBL:Nombre>: punt. al resultado resta de la tabla (ckeck-sum)
[CLAVE>
 |	clv<CLA:Nombre><TBL:Nombre>: indice de acceso por la clave <CLA:NOMBRE>
<CLAVE]
 |	max<TBL:Nombre>: numero maximo de elementos (redimensionado).
 +--------------------------------------------------------------------*/
static int  *pPos<TBL:Nombre> = NULL;
static int  *pNum<TBL:Nombre> = NULL;
static int  *pMax<TBL:Nombre> = NULL;
static int *pSum<TBL:Nombre> = NULL;
static int *pRes<TBL:Nombre> = NULL;
[CLAVE>
static int *clv<CLA:Nombre><TBL:Nombre> = NULL;
<CLAVE]
static int  max<TBL:Nombre> = MAX_<TBL:NOMBRE>;
<TABLA]

/*--------------------------------------------------------------------
 | Variables asociadas al registro de actualizacion:
 |	bufRegAct: buffer que almacena el registro de actualizacion.
 |	numActualiz: almacena el numero de actualizaciones.
 +--------------------------------------------------------------------*/
static TypeBUFFER	bufRegAct;
static int		numActualiz;

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_Directorio
 *	Notifica el directorio de donde  se debe cogen el fichero
 *	imagen de la Configuracion.
 *
 *    Parametros:
 *	- directorio: path del directorio.
 *====================================================================*/
void [+]_Directorio(char *directorio)
{
	char *nuevoPath;

/*--------------------------------------------------------------------
 | Se pide mem. dinamica para el path del fichero imagen.
 +--------------------------------------------------------------------*/
nuevoPath = (char *) malloc(strlen(directorio) + sizeof("[+].ibd") + 1);
if (nuevoPath == NULL)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_Directorio", "malloc",
		 "(%d bytes) path del fichero imagen", lonMemoria);

/*--------------------------------------------------------------------
 | Se compone el nuevo path.
 +--------------------------------------------------------------------*/
sprintf(nuevoPath, "%s/[+].ibd", directorio);
fichImagen = nuevoPath;
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_Dimensionar
 *	Notifica la nueva dimension de una determinada tabla. Siempre
 *	debe ser menor o igual a la definida como maxima.
 *	Si el codigo de tabla no es correcto o el valor de la nueva
 *	dimension supera el maximo definido, no se actualiza la
 *	dimension.
 *
 *    Parametros:
 *	- tabla: identificador de la tabla a dimensionar.
 *	- dimension: valor de la nueva dimension.
 *====================================================================*/
void [+]_Dimensionar(int tabla, int dimension)
{
switch(tabla) {
[TABLA>
    case TBL_<TBL:NOMBRE>:
	/*------------------------------------------------------------
	 | Si la dimension es mayor que la definida como maxima para la
	 | tabla <TBL:NOMBRE> no se acepta y se da un error.
	 +------------------------------------------------------------*/
	if (dimension > MAX_<TBL:NOMBRE>)
	    ERR_Aplicacion(ERR_NO_FATAL, FUNC_BDT, "[+]_Dimensionar",
	      "redimensionado %d de <TBL:NOMBRE> excesivo (max: <TBL:dimMax>)",
	       dimension);
	else
	    max<TBL:Nombre> = dimension;
	break;
<TABLA]
    }
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_CheckSum
 *	Obtiene el valor de la suma y resta de control de check-sum.
 *	Si la tabla no existe, se asigna 0 y -1 a suma y resta.
 *
 *    Parametros:
 *	tabla:  codigo de la tabla.
 *	pSuma:  puntero para dejar la suma.
 *	pResta: puntero para dejar la resta.
 *====================================================================*/
void [+]_CheckSum(int tabla, int *pSuma, int *pResta)
{
/*--------------------------------------------------------------------
 | Se asigna el valor de suma y resta segun la tabla.
 +--------------------------------------------------------------------*/
switch(tabla) {
[TABLA>
    case TBL_<TBL:NOMBRE>:
	*pSuma	= *pSum<TBL:Nombre>;
	*pResta = *pRes<TBL:Nombre>;
	break;
<TABLA]
    default:
	*pSuma	= 0L;
	*pResta = -1L;
	break;
    }
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_CreBase
 *	Crea la memoria compartida y semaforos de la Configuracion.
 *	Inicializa la memoria on el fichero Configuracion.
 *	Inicializa los array de punteros de las claves.
 *====================================================================*/
void [+]_CreBase()
{
	key_t clave;
	SEMUN unSemaf;
 	unsigned short arraySemaf[numSEMAF];

/*--------------------------------------------------------------------
 | Se obtiene la clave para la memoria compartida y los semaforos.
 +--------------------------------------------------------------------*/
clave = ftok(fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se intenta acceder a los semaforos y si existe, se borra, pues debe
 | ser de una ejecucion anterior.
 +--------------------------------------------------------------------*/
if (semget(clave, 0, 0) != -1)
    semctl(identSem, 0, IPC_RMID);

/*--------------------------------------------------------------------
 | Se crea el identificador de los semaforos de acceso a la Configuracion
 +--------------------------------------------------------------------*/
identSem = semget(clave, numSEMAF, IPC_CREAT | 0666);
if (identSem == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_CreBase", "semget",
		"IPC_CREAT (clave: fichero \"%s\", identificador '%c')",
    		fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se inicializan los semaforos de control de acceso:
 |	- lectura   (0: lectores)
 |	- escritura (1: libre)
 +--------------------------------------------------------------------*/
arraySemaf[SEMAF_LECT] = 0;
arraySemaf[SEMAF_ESCR] = 0;
unSemaf.array = arraySemaf;
if (semctl(identSem, 0, SETALL, unSemaf) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_CreBase", "semctl",
		"SETALL (clave: fichero \"%s\", identificador '%c')",
    		fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se intenta acceder la m. compartida y si existe, se borra para
 | evitar conflictos con una posible version anterior.
 +--------------------------------------------------------------------*/
if (shmget(clave, 0, 0) != -1)
    shmctl(identMC, IPC_RMID, (struct shmid_ds *)NULL);

/*--------------------------------------------------------------------
 | Se calcula la memoria (segun el dimensionado) necesaria para la base.
 | Se crea la memoria compartida para la Configuracion.
 +--------------------------------------------------------------------*/
CalcularMemoria();
identMC = shmget(clave, (size_t)lonMemoria, IPC_CREAT | 0666);
if (identMC == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_CreBase", "shmget",
		"IPC_CREAT (clave: fichero \"%s\", identificador '%c')",
    		fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se accede a la memoria comartida.
 +--------------------------------------------------------------------*/
pMemoria = shmat(identMC, (char *)NULL, SHM_RND);
if (pMemoria == DMC_ERR)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_CreBase", "shmat",
	       "clave: fichero \"%s\", identificador '%c'", fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se inicializa el vector de proteccion contra la "signals"
 | Se guarda el modo de uso del fichero (abierto/ abrir y cerar).
 | Se pone el indicador de base privada a FALSO.
 +--------------------------------------------------------------------*/
sigfillset(&vectorSig);
sigdelset(&vectorSig,SIGTRAP);
sigdelset(&vectorSig,SIGBUS);
sigdelset(&vectorSig,SIGSEGV);
basePrivada = 0;

/*--------------------------------------------------------------------
 | Se inicializan los punt. de acceso a las zonas de la m. compartida.
 +--------------------------------------------------------------------*/
IniPunteros(1);
IniInformacion();
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_EliBase
 *	Libera los recursos de la base: memoria compartida y semaforos.
 *====================================================================*/
void [+]_EliBase()
{
/*--------------------------------------------------------------------
 | Se desengancha de la memoria compartida.
 | se borra el segmento de memoria compartida y el semaforo asociado
 | Se finaliza el acceso al fichero imagen.
 | OJO controlar lo devuelto por: shmdt shmctl semctl.
 +--------------------------------------------------------------------*/
if (shmdt(pMemoria) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EliBase", "shmdt", "");
if (shmctl(identMC, IPC_RMID, (struct shmid_ds *)NULL) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EliBase", "shmctl", "IPC_RMID");
if (semctl(identSem, 0, IPC_RMID) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EliBase", "semctl", "IPC_RMID");

/*--------------------------------------------------------------------
 | Se cierra el fichero imagen de la Configuracion (si esta abierto).
 +--------------------------------------------------------------------*/
if (fdFBD >= 0) {
    if (close(fdFBD) == -1)
	ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EliBase", "close",
		    "fichero \"%s\"", fichImagen);
    fdFBD = -1;
    }
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_IniAcceso
 *	Inicializa el acceso a la Configuracion que debe estar
 *	creada previamente.
 *====================================================================*/
void [+]_IniAcceso()
{
	key_t clave;

/*--------------------------------------------------------------------
 | Se obtiene la clave para la m. compartida y los semaforos.
 +--------------------------------------------------------------------*/
clave = ftok(fichImagen, ID_BDS);
identMC = shmget(clave, 0, 0);
if (identMC == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_IniAcceso", "shmget",
	       "clave: fichero \"%s\", identificador '%c'", fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se engancha a la m. compartida que debe estar ya creada.
 +--------------------------------------------------------------------*/
pMemoria = shmat(identMC, (char *)NULL, SHM_RND);
if (pMemoria == DMC_ERR)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_IniAcceso", "shmat",
	       "clave: fichero \"%s\", identificador '%c'", fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se accede a los semaforos que tambien debeb estar creados.
 +--------------------------------------------------------------------*/
identSem = semget(clave, 0, 0);
if (identSem == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_IniAcceso", "semget",
	       "clave: fichero \"%s\", identificador '%c'", fichImagen, ID_BDS);

/*--------------------------------------------------------------------
 | Se inicializa el vector de proteccion contra las "signals".
 | Se pone el indicador de base privada a FALSO.
 +--------------------------------------------------------------------*/
sigfillset(&vectorSig);
sigdelset(&vectorSig,SIGTRAP);
sigdelset(&vectorSig,SIGBUS);
sigdelset(&vectorSig,SIGSEGV);
basePrivada = 0;

/*--------------------------------------------------------------------
 | Se inicializan los punteros de acceso a las tablas.
 +--------------------------------------------------------------------*/
IniPunteros(0);
}

/*========================= FUNCION PUBLICA =========================
 * [+]_FinAcceso
 *	Finaliza el acceso a la Configuracion.
 *====================================================================*/
void [+]_FinAcceso()
{
/*--------------------------------------------------------------------
 | Se desengancha de la memoria compartida
 +--------------------------------------------------------------------*/
if (shmdt(pMemoria) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_FinAcceso", "shmdt", "");

/*--------------------------------------------------------------------
 | Se cierra el fichero imagen de la Configuracion (si esta abierto).
 +--------------------------------------------------------------------*/
if (fdFBD >= 0) {
    if (close(fdFBD) == -1)
	ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_FinAcceso", "close",
		    "fichero \"%s\"", fichImagen);
    fdFBD = -1;
    }
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_CrePrivada
 *	Inicializa la Configuracion como local creandola e iniciando
 *	el acceso.
 *====================================================================*/
void [+]_CrePrivada()
{
/*--------------------------------------------------------------------
 | Se calcula la memoria (segun el dimensionado) necesaria para la base.
 | Se pide memoria dinamica para la Configuracion.
 +--------------------------------------------------------------------*/
CalcularMemoria();
pMemoria = (char *) malloc(lonMemoria);
if (pMemoria == NULL)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_CrePrivada", "malloc",
		"(%d bytes) memoria para la Configuracion", lonMemoria);

/*--------------------------------------------------------------------
 | Se pone el indicador de base privada a CIERTO.
 | Se guarda el modo de uso del fichero (abierto siempre o abrir y cerar).
 +--------------------------------------------------------------------*/
basePrivada = 1;

/*--------------------------------------------------------------------
 | Se inicializan los punteros de acceso a la memoria.
 | Se inicializan los arrays de indices de acceso por clave.
 +--------------------------------------------------------------------*/
IniPunteros(1);
IniInformacion();
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_EliPrivada
 *	Finaliza el acceso local a la Configuracion.
 *
 *	Devuelve:
 *	0: si se elimina correctamente.
 *	-1: si hay error.
 *====================================================================*/
void [+]_EliPrivada()
{
/*--------------------------------------------------------------------
 | Se libera la memoria dinamica.
 +--------------------------------------------------------------------*/
free(pMemoria);

/*--------------------------------------------------------------------
 | Se cierra el fichero imagen de la Configuracion.
 +--------------------------------------------------------------------*/
if (fdFBD >= 0) {
    if (close(fdFBD) == -1)
	ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EliPrivada", "close",
		    "fichero \"%s\"", fichImagen);
    fdFBD = -1;
    }
}
[TABLA>

[CLAVE PRINCIPAL>
/*========================= FUNCION PUBLICA =========================
 * [+]_<TBL:Nombre>Por<CLA:Nombre>
 *	Busca un elemento <TBL:NOMBRE>, por la clave principal
 *	para lo cual la struct debe tener todos los campos de la
 *	clave con los valores actualizados.
 *
 *    Parametros:
 *	p<TBL:Nombre>: punt. a la struct del elemento a buscar.
 [CAMPO CLAVE> *	<CAM:nombre>: campo <CAM:NOMBRE> de busqueda.
 <CAMPO CLAVE]
 *    Devuelve:
 *	 0: si el elemento es encontrado.
 *	-1: si el elemento no existe
 *====================================================================*/
int [+]_<TBL:Nombre>Por<CLA:Nombre>(Type<TBL:NOMBRE> *p<TBL:Nombre>[CAMPO CLAVE>,
				<CAM:tipoC><CAMPO CLAVE])
{
	int  indElem;

/*--------------------------------------------------------------------
 | Se codifican los campos de la clave principal sobre el elemento.
 +--------------------------------------------------------------------*/
[CAMPO CLAVE>
<CAM:copEst>;
<CAMPO CLAVE]

/*--------------------------------------------------------------------
 | Se busca el elemento accediendo por la clave principal y si no
 | existe se devuelve -1.
 +--------------------------------------------------------------------*/
AccLectura();
indElem = BuscaElemento(p<TBL:Nombre>, clv<CLA:Nombre><TBL:Nombre>,
	      *pNum<TBL:Nombre>, (PF_COMPAR)Cmp<CLA:Nombre><TBL:Nombre>);
if (indElem == -1) {
    SalLectura();
    return -1;
    }

/*--------------------------------------------------------------------
 | Si existe, se decodifica el elemento completo sobre la struct.
 +--------------------------------------------------------------------*/
memcpy(p<TBL:Nombre>, DIR_MEM(clv<CLA:Nombre><TBL:Nombre>[indElem]), TAM_<TBL:NOMBRE>);
SalLectura();

return 0;
}
<CLAVE]

[CLAVE UNICA>
/*========================= FUNCION PUBLICA =========================
 * [+]_<TBL:Nombre>Por<CLA:Nombre>
 *	Busca un elemento <TBL:NOMBRE> , por la clave <CLA:NOMBRE>
 *	para lo cual la struct debe tener todos los campos de la
 *	clave con los valores actualizados.
 *
 *    Parametros:
 *	p<TBL:Nombre>: punt. a la struct del elemento a buscar.
 [CAMPO CLAVE> *	<CAM:nombre>: campo <CAM:NOMBRE> de busqueda.
 <CAMPO CLAVE]
 *    Devuelve:
 *	 0: si el elemento es encontrado.
 *	-1: si el elemento no existe
 *====================================================================*/
int [+]_<TBL:Nombre>Por<CLA:Nombre>(Type<TBL:NOMBRE> *p<TBL:Nombre>[CAMPO CLAVE>,
				<CAM:tipoC><CAMPO CLAVE])
{
	int  indElem;

/*--------------------------------------------------------------------
 | Se codifican los campos de la clave principal sobre el elemento.
 +--------------------------------------------------------------------*/
[CAMPO CLAVE>
<CAM:copEst>;
<CAMPO CLAVE]

/*--------------------------------------------------------------------
 | Se busca el elemento accediendo por la clave principal y si no
 | existe se devuelve -1.
 +--------------------------------------------------------------------*/
AccLectura();
indElem = BuscaElemento(p<TBL:Nombre>, clv<CLA:Nombre><TBL:Nombre>,
	      *pNum<TBL:Nombre>, (PF_COMPAR)Cmp<CLA:Nombre><TBL:Nombre>);
if (indElem == -1) {
    SalLectura();
    return -1;
    }

/*--------------------------------------------------------------------
 | Si existe, se decodifica el elemento completo sobre la struct.
 +--------------------------------------------------------------------*/
memcpy(p<TBL:Nombre>, DIR_MEM(clv<CLA:Nombre><TBL:Nombre>[indElem]), TAM_<TBL:NOMBRE>);
SalLectura();

return 0;
}
<CLAVE]


/*========================= FUNCION PUBLICA =========================
 * [+]_Vol<TBL:Nombre>
 *	Realiza un volcado de la tabla <TBL:NOMBRE> ordenado por
 *	la clave segun el parametro.
 *    Parametros:
 *	claveOrd: codigo de la clave para ordenar el volcado.
 *	pLista: puntero para la lista del volcado.
 *    Devuelve:
 *	n: el numero de elementos seleccionados.
 *	0: si hay error en el acceso.
 *====================================================================*/
int [+]_Vol<TBL:Nombre>(int claveOrd, Type<TBL:NOMBRE> **pLista)
{
	int i;
	Type<TBL:NOMBRE> *p<TBL:Nombre>;
	int *claveAcceso;

/*--------------------------------------------------------------------
 | Se recoge el array de acceso por la clave definida por "claveOrd"
 +--------------------------------------------------------------------*/
claveAcceso = Clave<TBL:Nombre>(claveOrd);
if (claveAcceso == NULL)
    return 0;

/*--------------------------------------------------------------------
 | Si la tabla esta vacia no se hace nada mas y se devuelve 0.
 +--------------------------------------------------------------------*/
AccLectura();
if (*pNum<TBL:Nombre> == 0) {
    SalLectura();
    return 0;
    }

/*--------------------------------------------------------------------
 | Se pide memoria dinamica para almacenar los elementos del recorrido.
 +--------------------------------------------------------------------*/
p<TBL:Nombre> = (Type<TBL:NOMBRE> *) malloc(*pNum<TBL:Nombre> * TAM_<TBL:NOMBRE>);
if (p<TBL:Nombre> == NULL) {
    ERR_SistOper(ERR_NO_FATAL, FUNC_BDT, "[+]_Vol<TBL:Nombre>",
	     "malloc", "(%d bytes) para volcado de <TBL:Nombre>", lonMemoria);
    SalLectura();
    return 0;
    }

*pLista = p<TBL:Nombre>;

/*--------------------------------------------------------------------
 | Se copia la informacion de cada elemento de la lista segun la
 | ordenacion de la clave.
 +--------------------------------------------------------------------*/
for (i = 0; i < *pNum<TBL:Nombre>; i++) {
    memcpy(p<TBL:Nombre>, DIR_MEM(claveAcceso[i]), TAM_<TBL:NOMBRE>);
    p<TBL:Nombre>++;
    }

SalLectura();
return i;
}

[SELECCION>
/*========================= FUNCION PUBLICA =========================
 * [+]_Sel<TBL:Nombre>Por<SEL:Nombre>
 *	Realiza una seleccion de la tabla <TBL:NOMBRE> segun el
 *	criterio <SEL:NOMBRE> y ordenado por una clave segun parametro.
 *
 *    Parametros:
 *	claveOrd: codigo de la clave para ordenar el volcado.
 *	pLista: puntero a la lista de la seleccion.
[PARAMETRO SELECCION> *	<PRS:nombre>: valor para la seleccion.
<PARAMETRO SELECCION]
 *    Devuelve:
 *	n: numero de elementos seleccionados (puede ser 0).
 *	-1: si hay error en la seleccion.
 *====================================================================*/
int [+]_Sel<TBL:Nombre>Por<SEL:Nombre>(int claveOrd,
			Type<TBL:NOMBRE> **pLista[PARAMETRO SELECCION>,
			<PRS:tipoC><PARAMETRO SELECCION])
{
	int   i;
	int   totSelec;
	Type<TBL:NOMBRE> *p<TBL:Nombre>;
	Type<TBL:NOMBRE> lstSelec[MAX_<TBL:NOMBRE>];
	int *claveAcceso;

/*--------------------------------------------------------------------
 | Se recoge el array de acceso por la clave definida por "claveOrd"
 +--------------------------------------------------------------------*/
claveAcceso = Clave<TBL:Nombre>(claveOrd);
if (claveAcceso == NULL)
    return 0;

/*--------------------------------------------------------------------
 | Si la tabla esta vacia no se hace nada mas y se devuelve 0.
 +--------------------------------------------------------------------*/
AccLectura();
if (*pNum<TBL:Nombre> == 0) {
    SalLectura();
    return 0;
    }

/*--------------------------------------------------------------------
 | Se recorre toda la tabla, decodificando cada elemento sobre el
 | elemento siguiente de la lista. Si cumple la condicion de seleccion
 | se avanza el puntero al siguiente elemento y se incrementa el numero
 | de elementos seleccionados.
 +--------------------------------------------------------------------*/
totSelec = 0;
for (i = 0; i < *pNum<TBL:Nombre>; i++) {
[CLAVE PRINCIPAL>
    p<TBL:Nombre> = (Type<TBL:NOMBRE> *) DIR_MEM(claveAcceso[i]);
<CLAVE]
    if (<SEL:expres>) {
	memcpy(lstSelec + totSelec, p<TBL:Nombre>, TAM_<TBL:NOMBRE>);
	totSelec++;
	}
    }
SalLectura();

/*--------------------------------------------------------------------
 | Se pide memoria dinamica para almacenar los elementos de seleccion
 | (solo si se ha seleccionado alguno y se copian sobre esta memoria.
 +--------------------------------------------------------------------*/
i = totSelec * TAM_<TBL:NOMBRE>;
if (i > 0) {
    *pLista = (Type<TBL:NOMBRE> *) malloc((size_t) i);
    if (*pLista == NULL) {
	ERR_SistOper(ERR_NO_FATAL, FUNC_BDT,
		"[+]_Sel<TBL:Nombre>Por<SEL:Nombre>", "malloc",
		"(%d bytes) para la seleccion <SEL:Nombre> de <TBL:Nombre>", i);
	return 0;
	}
    memcpy((void *) *pLista, (void *) lstSelec, i);
    }
return totSelec;
}
<SELECCION]

/*========================= FUNCION PUBLICA =========================
 * [+]_Cod<TBL:Nombre>
 *	Codifica un Type<TBL:NOMBRE> sobre un elemento <TBL:Nombre>.
 *    Parametros:
 *      elem: buffer del elemento sobre el que codificar.
 *	p<TBL:Nombre>: struct a realizar la codificacion.
 *    Devuelve:
 *	la longitud del elemento codificado.
 *====================================================================*/
int [+]_Cod<TBL:Nombre>(char *elem, Type<TBL:NOMBRE> *p<TBL:Nombre>)
{
[CAMPO>
<CAM:codEst>;
<CAMPO]
return LON_<TBL:NOMBRE>;
}

/*========================= FUNCION PUBLICA =========================
 * [+]_Dec<TBL:Nombre>
 *	Decodifica un elemento <TBL:Nombre> sobre un Type<TBL:NOMBRE>
 *    Parametros:
 *      elem: buffer del elemento a decodificar.
 *	p<TBL:Nombre>: struct sobre la que realizar la decodificacion.
 *    Devuelve:
 *	la longitud del elemento codificado.
 *====================================================================*/
int [+]_Dec<TBL:Nombre>(char *elem, Type<TBL:NOMBRE> *p<TBL:Nombre>)
{
[CAMPO>
<CAM:decEst>;
<CAMPO]
return LON_<TBL:NOMBRE>;
}
<TABLA]

/*========================= FUNCION PUBLICA =========================
 * [+]_AnaOperacion
 *	Analiza si una operacion sobre una tabla es consistente con
 *	la integridad de la base.
 *
 *    Parametros:
 *	operacion: a analizar (BDT_INSERTAR/BDT_ELIMINAR/BDT_MODIFICAR)
 *	tabla: codigo de la tabla a la que pertenece el elemento.
 *	pElemento: puntero al elemento a actualizar.
 *    Devuelve:
 *	el valor devuelto por AnaIntegridadOperacion.
 *====================================================================*/
int [+]_AnaOperacion(char operacion, int tabla, void *pElemento)
{
	int result;

/*--------------------------------------------------------------------
 | Se realiza el acceso para lectura, Se analiza la operacion y se
 | sale, devolviendo el resultado del analisis.
 +--------------------------------------------------------------------*/
AccLectura();
result = AnaIntegridadOperacion(operacion, tabla, pElemento);
SalLectura();
return result;
}

/*========================= FUNCION PRIVADA =========================
 * AnaIntegridadOperacion
 *	Analiza si una operacion sobre una tabla es consistente con
 *	la integridad de la base.
 *
 *    Parametros:
 *	operacion: a analizar (BDT_INSERTAR/BDT_ELIMINAR/BDT_MODIFICAR)
 *	tabla: codigo de la tabla a la que pertenece el elemento.
 *	pElemento: puntero al elemento a actualizar.
 *    Devuelve:
 *	el indice a la clave principal: si la operacion es correcta.
 *	-1: error de integridad asociado a la clave principal.
 *	-2: error de integridad asociado a la clave secundaria.
 *	-3: overflow.
 *	-4: error de parametros (operacion o tabla).
 *====================================================================*/
static int AnaIntegridadOperacion(char operacion, int tabla, void *pElemento)
{
	int indElem;

switch(tabla) {
[TABLA>
    case TBL_<TBL:NOMBRE>: {
    		Type<TBL:NOMBRE> *p<TBL:Nombre>;
	p<TBL:Nombre> = (Type<TBL:NOMBRE> *) pElemento;
[CLAVE PRINCIPAL>
	/*------------------------------------------------------------
	 | Se busca el elemento en la tabla <TBL:NOMBRE>
	 +------------------------------------------------------------*/
	indElem = BuscaElemento(p<TBL:Nombre>, clv<CLA:Nombre><TBL:Nombre>,
		     *pNum<TBL:Nombre>, (PF_COMPAR)Cmp<CLA:Nombre><TBL:Nombre>);
<CLAVE]
	switch(operacion) {
	    case BDT_INSERTAR:
		/*----------------------------------------------------
		 | No debe existir otro elemento con igual valor en la
		 | clave principal.
		 +----------------------------------------------------*/
		if (indElem >= 0)
		    return -1;
[CLAVE UNICA>
		/*----------------------------------------------------
		 | No debe existir otro elemento con igual valor en la
		 | clave secundaria unica: <CLA:NOMBRE>.
		 +----------------------------------------------------*/
		if (BuscaElemento(p<TBL:Nombre>, clv<CLA:Nombre><TBL:Nombre>,
			*pNum<TBL:Nombre>, (PF_COMPAR)Cmp<CLA:Nombre><TBL:Nombre>) >= 0)
		    return -2;
<CLAVE]
		/*----------------------------------------------------
		 | No debe sobrepasar el maximo de elementos definido.
		 +----------------------------------------------------*/
		if (*pNum<TBL:Nombre> >= *pMax<TBL:Nombre>)
		    return -3;
		/*----------------------------------------------------
		 | Para insercion se coge el siguiente libre,
		 +----------------------------------------------------*/
		indElem =  *pNum<TBL:Nombre>;
		break;
	    case BDT_ELIMINAR:
		/*----------------------------------------------------
		 | Debe existir el elemento con igual valor en la
		 | clave principal (elemento a eliminar).
		 +----------------------------------------------------*/
		if (indElem < 0)
		    return -1;
		break;
	    case BDT_MODIFICAR: {
			Type<TBL:NOMBRE> *pActual;
[CLAVE PRINCIPAL>
		pActual = (Type<TBL:NOMBRE> *)
				DIR_MEM(clv<CLA:Nombre><TBL:Nombre>[indElem]);
<CLAVE]
		/*------------------------------------------------------------
		 | Debe existir el elemento con igual valor en la clave
		 | principal (elemento a modificar).
		 +------------------------------------------------------------*/
		if (indElem < 0)
		    return -1;

[CLAVE UNICA>
		/*------------------------------------------------------------
		 | Si el elemento actual y el nuevo no coinciden en la clave
		 | unica <CLA:NOMBRE>, entonces no se admite que otro elemento
		 | la contenga (puesto que es clave unica).
		 +------------------------------------------------------------*/
		if (Cmp<CLA:Nombre><TBL:Nombre>(p<TBL:Nombre>, pActual) &&
		    (BuscaElemento(p<TBL:Nombre>, clv<CLA:Nombre><TBL:Nombre>,
		      		*pNum<TBL:Nombre>,
				(PF_COMPAR)Cmp<CLA:Nombre><TBL:Nombre>) >= 0))
		    return -2;
<CLAVE]
		}
		break;
	    }
	}
	break;
<TABLA]
    default:
	return -4;
	break;
    }

return indElem;
}

/*========================= FUNCION PUBLICA =========================
 * [+]_EjecutarRegAct
 *	Ejecuta un registro de actualizacion sobre la base.
 *
 *    Parametros:
 *	pRegAct: puntero al registro de actualizacion.
 *    Devuelve:
 *	0: si la actualizacion es correcta.
 *	valor devuelto por AnaIntegridadOperacion: si hay errores.
 *====================================================================*/
int [+]_EjecutarRegAct(char *pRegAct)
{
	int   numRegs;
	char  operacion;
	int   tabla;
	int   indClave;
	int   indElem;
	int   posicMem;
	int   posicFic;

	char *pEleCod;
	int   lonEleCod;

/*--------------------------------------------------------------------
 | Se se realiza el acceso para escritura.
 +--------------------------------------------------------------------*/
AccEscritura();

pRegAct += TPC_DecInt(&numRegs, 1, pRegAct);
while (numRegs > 0) {
    /*--------------------------------------------------------------------
     | Se obtienen: la operacion, la tabla y el elemento a actualizar.
     +--------------------------------------------------------------------*/
    pRegAct += TPC_DecChar(&operacion, 1, pRegAct);
    pRegAct += TPC_DecInt(&tabla, 1, pRegAct);
    pEleCod  = pRegAct;
    numRegs--;

    switch(tabla) {
[TABLA>
	case TBL_<TBL:NOMBRE>: {
		Type<TBL:NOMBRE> <TBL:nombre>;
	    /*------------------------------------------------------------
	     | Se obtiene el indice de la clave principal segun la operacion.
	     +------------------------------------------------------------*/
	    [+]_Dec<TBL:Nombre>(pEleCod, &<TBL:nombre>);
	    indClave = AnaIntegridadOperacion(operacion, tabla, &<TBL:nombre>);
	    if (indClave < 0) {
		SalEscritura();
		return indClave;
		}

	    /*------------------------------------------------------------
	     | Se calcula la posicion en fichero y memoria, y se avanza el
	     | punt. del registro de actualiz. segun la long. del elemento
	     | Se escribe el elemento en la memoria (decodificandolo).
	     +------------------------------------------------------------*/
[CLAVE PRINCIPAL>
	    posicMem  = clv<CLA:Nombre><TBL:Nombre>[indClave];
<CLAVE]
	    indElem   = IND_<TBL:NOMBRE>(posicMem);
	    posicFic  = ELE_<TBL:NOMBRE>(indElem);
	    lonEleCod = LON_<TBL:NOMBRE>;
	    memcpy(DIR_MEM(posicMem), (void *)&<TBL:nombre>, TAM_<TBL:NOMBRE>);

	    /*--------------------------------------------------------
	     | Se completa la ejecucion segun la operacion a realizar.
	     +--------------------------------------------------------*/
	    switch(operacion) {
		case BDT_INSERTAR:
		    /*------------------------------------------------
		     | Se recalcula el check-sum sumando el elem. nuevo.
		     +------------------------------------------------*/
		    CalcSumaResta(pEleCod, LON_<TBL:NOMBRE>, 1,
				  pSum<TBL:Nombre>, pRes<TBL:Nombre>);

		    /*------------------------------------------------
		     | En insercion se incrementa el numero de elementos
		     | y se realiza la ordenacion con el nuevo elemento.
		     +------------------------------------------------*/
		    (*pNum<TBL:Nombre>)++;
		    Ord<TBL:Nombre>();
		    break;
 
		case BDT_ELIMINAR:
		    /*------------------------------------------------
		     | Se recalcula el check-sum restando el elem. viejo.
		     +------------------------------------------------*/
		    CalcSumaResta(pEleCod, LON_<TBL:NOMBRE>, 0,
				pSum<TBL:Nombre>, pRes<TBL:Nombre>);

		    /*------------------------------------------------
		     | Se elimina la posicion de cada una de las claves.
		     | No es necesario reordenar las claves.
		     +------------------------------------------------*/
[CLAVE>
		    PosicionLibre(posicMem, clv<CLA:Nombre><TBL:Nombre>,
		    		*pNum<TBL:Nombre>);
<CLAVE]
		    (*pNum<TBL:Nombre>)--;
		    break;

		case BDT_MODIFICAR: {
			char viejoCod[LON_<TBL:NOMBRE>];

		    /*------------------------------------------------
		     | Se recalcula el check-sum restando el elemento
		     | viejo (codificado) y sumando el nuevo.
		     +------------------------------------------------*/
		    [+]_Cod<TBL:Nombre>(viejoCod,
		    		(Type<TBL:NOMBRE> *) DIR_MEM(posicMem));
		    CalcSumaResta(viejoCod, LON_<TBL:NOMBRE>, 0,
				pSum<TBL:Nombre>, pRes<TBL:Nombre>);
		    CalcSumaResta(pEleCod, LON_<TBL:NOMBRE>, 1,
				pSum<TBL:Nombre>, pRes<TBL:Nombre>);

		    /*------------------------------------------------
		     | En la modificacion no se alteran las posiciones de clave,
		     | de clave, solo se realiza la ordenacion.
		     +------------------------------------------------*/
		    Ord<TBL:Nombre>();
		    break;
		    }
		}
	    }
	    break;
<TABLA]
	}

    /*--------------------------------------------------------------------
     | Se abre el fichero imagen de la Configuracion (si no esta abierto)
     +--------------------------------------------------------------------*/
    if (fdFBD < 0) {
	fdFBD = open(fichImagen, O_RDWR | O_EXCL);
	if (fdFBD == -1) {
	    SalEscritura();
	    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EjecutarRegAct", "open",
			"fichero \"%s\" (para lectura/escritura)", fichImagen);
	    }
	}
 
    /*--------------------------------------------------------------------
     | Se prepara la escritura sobre la posicion del elemento.
     +--------------------------------------------------------------------*/
    if (lseek(fdFBD, (off_t)posicFic, SEEK_SET) == -1) {
	SalEscritura();
	ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EjecutarRegAct", "lseek",
			"fichero \"%s\" (posicion %ld)", fichImagen, posicFic);
	}

    /*--------------------------------------------------------------------
     | Se escribe el elemento sobre el fichero.
     +--------------------------------------------------------------------*/
    if (write(fdFBD, pEleCod, lonEleCod) != lonEleCod) {
	SalEscritura();
	ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]_EjecutarRegAct", "write",
			"fichero \"%s\" (%d bytes)", fichImagen, lonEleCod);
	}
    /*--------------------------------------------------------------------
     | Se avanza el punt. del registro de actualiz. la longitud del elemento
     +--------------------------------------------------------------------*/
    pRegAct += lonEleCod;
    }

/*--------------------------------------------------------------------
 | Se se realiza la salida para escritura.
 +--------------------------------------------------------------------*/
SalEscritura();
return 0;
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_IniciarRegAct
 *	Inicia la generacion de un nuevo registro de actualizacion.
 *====================================================================*/
void [+]_IniciarRegAct()
{
	static int primerReg = 1;

/*------------------------------------------------------------------------
 | Si es la primera vez, se crea el buffer para el registro de actualiz.
 | Se inicia el buffer para comenzar la generacion del registro.
 +------------------------------------------------------------------------*/
if (primerReg) {
    primerReg = 0;
    BUF_Crear(&bufRegAct, 64, 64);
    }
BUF_Iniciar(&bufRegAct);

/*------------------------------------------------------------------------
 | Se reserva el sitio para poner el numero de actualizaciones al principio.
 | Se inicia el numero de actualizaciones a 0.
 +------------------------------------------------------------------------*/
BUF_Reservar(&bufRegAct, TPC_TAM_COD_INT);
BUF_Avanzar(&bufRegAct, TPC_TAM_COD_INT);
numActualiz = 0;
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_IncrementarRegAct
 *	Incrementa el registro de actualizacion con una nueva operacion
 *	de un elemento sobre una tabla.
 *
 *    Parametros:
 *	operacion: codigo de la operacion.
 *	tabla: codigo de la tabla.
 *	pElemento: puntero a la struct del elemento.
 *====================================================================*/
void [+]_IncrementarRegAct(char operacion, int tabla, void *pElemento)
{
	char *pBuff;
	char *pEleCod;

/*------------------------------------------------------------------------
 | Se reserva el espacio para la operacion y la tabla y se escriben este.
 +------------------------------------------------------------------------*/
pBuff  = BUF_Reservar(&bufRegAct, TPC_TAM_COD_CHAR + TPC_TAM_COD_INT);
pBuff += TPC_CodChar(&operacion, 1, pBuff);
TPC_CodInt(&tabla, 1, pBuff);
BUF_Avanzar(&bufRegAct, TPC_TAM_COD_CHAR + TPC_TAM_COD_INT);

/*------------------------------------------------------------------------
 | Segun la tabla, se reserva espacio para el elemento y se codifica en este.
 +------------------------------------------------------------------------*/
switch(tabla) {
[TABLA>
    case TBL_<TBL:NOMBRE>:
	pEleCod = BUF_Reservar(&bufRegAct, LON_<TBL:NOMBRE>);
	[+]_Cod<TBL:Nombre>(pEleCod, (Type<TBL:NOMBRE> *) pElemento);
	BUF_Avanzar(&bufRegAct, LON_<TBL:NOMBRE>);
	break;
<TABLA]
    }

/*------------------------------------------------------------------------
 | Si la operacion es ELIMINAR, se pone el elemento como libre, en el resto
 | de los casos, INSERTAR o MODIFICAR, se pone ocupado.
 | Se incrementa el numero de actualizaciones.
 +------------------------------------------------------------------------*/
if (operacion == BDT_ELIMINAR)
    PONER_LIBRE(pEleCod);
else
    PONER_OCUPADO(pEleCod);
numActualiz++;
}

/*====================== PROCEDIMIENTO PUBLICO ======================
 * [+]_ObtenerRegAct
 *	Obtiene el valor actual del registro de actualizacion.
 *
 *    Parametros:
 *	pRegAct: puntero para el registro de actualizacion.
 *	pLonReg: puntero para la longitud del registro.
 *====================================================================*/
void [+]_ObtenerRegAct(char **pRegAct, int *pLonReg)
{
/*------------------------------------------------------------------------
 | Se obtienen los datos del buffer del registro de actualizacion.
 | Se codifica el numero de actualiz. en la posicion reservada (en inicio).
 +------------------------------------------------------------------------*/
BUF_Obtener(&bufRegAct, pRegAct, pLonReg);
TPC_CodInt(&numActualiz, 1, *pRegAct);
}

/*====================================================================
 |	 	FUNIONES LOCALES DEPENDIENTES DE LA BASE
 =====================================================================*/

/*====================== PROCEDIMIENTO PRIVADO ======================
 * AccLectura
 *	Realiza el acceso a la Configuracion (region critica) para
 *	lectura.
 *====================================================================*/
static void AccLectura()
{
	static struct sembuf opSem1   = { SEMAF_ESCR, 0,  SEM_UNDO};
	static struct sembuf opSem2[] = { SEMAF_LECT,  1, SEM_UNDO};

/*--------------------------------------------------------------------
 | Si la Configuracion se ha creado como privada, no se usan semaforos.
 +--------------------------------------------------------------------*/
if (basePrivada)
    return;

/*--------------------------------------------------------------------
 | Se bloquean las senales mientras se accede
 +--------------------------------------------------------------------*/
if (sigprocmask(SIG_BLOCK, &vectorSig, NULL) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccLectura",
			"sigprocmask", "SIG_BLOCK");

/*--------------------------------------------------------------------
 | Peticion de bloqueo del semaforo de escritura:  P (get)
 +--------------------------------------------------------------------*/
if (semop(identSem, &opSem1, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccLectura",
			"semop", "operacion: P (get)");

/*--------------------------------------------------------------------
 | No hay escritores: se indica un nuevo lector y V (release)
 +--------------------------------------------------------------------*/
if (semop(identSem, opSem2, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccLectura",
			"semop", "operacion: V (release)");
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * AccEscritura
 *	Realiza el acceso a la Configuracion (region critica) para
 *	escritura.
 *====================================================================*/
static void AccEscritura()
{
	static struct sembuf opSem1 = { SEMAF_ESCR,  1, SEM_UNDO };
	static struct sembuf opSem2 = { SEMAF_LECT,  0, SEM_UNDO };

/*--------------------------------------------------------------------
 | Si la Configuracion se ha creado como privada, no se usan semaforos.
 +--------------------------------------------------------------------*/
if (basePrivada)
    return;

/*--------------------------------------------------------------------
 | Se bloquean las senales mientras se accede
 +--------------------------------------------------------------------*/
if (sigprocmask(SIG_BLOCK, &vectorSig, NULL) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccEscritura",
			"sigprocmask", "SIG_BLOCK");

/*--------------------------------------------------------------------
 | Peticion de bloqueo del semaforo de escritura:  P (get)
 +--------------------------------------------------------------------*/
if (semop(identSem, &opSem1, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccEscritura",
			"semop", "operacion: P (get)");

/*--------------------------------------------------------------------
 | Espera a que no queden lectores.
 +--------------------------------------------------------------------*/
if (semop(identSem, &opSem2, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: AccEscritura",
			"semop", "operacion: espera a los lectores");
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * SalLectura
 *	Realiza la salida de la Configuracion (region critica) en
 *	lectura.
 *====================================================================*/
static void SalLectura()
{
	static struct sembuf opSem = { SEMAF_LECT, -1, SEM_UNDO };

/*--------------------------------------------------------------------
 | Si la Configuracion se ha creado como privada, no se usan semaforos.
 +--------------------------------------------------------------------*/
if (basePrivada)
    return;

/*--------------------------------------------------------------------
 | Se libera el semaforo de los lectores.
 +--------------------------------------------------------------------*/
if (semop(identSem, &opSem, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: SalLectura",
			"semop", "operacion: liberacion de semaforo");

/*--------------------------------------------------------------------
 | Se desbloquean las senales despues del acceso.
 +--------------------------------------------------------------------*/
if (sigprocmask(SIG_UNBLOCK, &vectorSig, NULL) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: SalLectura",
			"sigprocmask", "SIG_UNBLOCK");
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * SalEscritura
 *	Realiza la salida de la Configuracion (region critica) en
 *	escritura.
 *====================================================================*/
static void SalEscritura()
{
	static struct sembuf opSem = { SEMAF_ESCR, -1, SEM_UNDO };

/*--------------------------------------------------------------------
 | Si la Configuracion se ha creado como privada, no se usan semaforos.
 +--------------------------------------------------------------------*/
if (basePrivada)
    return;

/*--------------------------------------------------------------------
 | Se libera el semaforo de los escritor.
 +--------------------------------------------------------------------*/
if (semop(identSem, &opSem, 1) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: SalEscritura",
		 "semop", "operacion: liberacion de semaforo");

/*--------------------------------------------------------------------
 | Se desbloquean las senales despues del acceso.
 +--------------------------------------------------------------------*/
if (sigprocmask(SIG_UNBLOCK, &vectorSig, NULL) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: SalEscritura",
			"sigprocmask", "SIG_UNBLOCK");
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * IniInformacion
 *	Inicializa el acceso al fichero imagen de la Configuracion y
 *	se lee su contenido sobre la memoria dinamica.
 *====================================================================*/
static void IniInformacion()
{
	int   indOcu;
	int   indLib;
	int   indAct;
	char *pElem;
	int   i;  

/*--------------------------------------------------------------------
 | Se mira si el fichero imagen de la Configuracion existe
 +--------------------------------------------------------------------*/
if (access(fichImagen, F_OK) == -1)
    ERR_Aplicacion(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion",
		   "fichero \"%s\" no existente", fichImagen);

/*--------------------------------------------------------------------
 | Se mira si el fichero imagen de Config. tiene permiso de lectura
 +--------------------------------------------------------------------*/
if (access(fichImagen, R_OK) == -1)
    ERR_Aplicacion(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion",
		   "fichero \"%s\" no accesible para lectura", fichImagen);

/*--------------------------------------------------------------------
 | Se mira si el fichero imagen de Config. tiene permiso de escritura
 +--------------------------------------------------------------------*/
if (access(fichImagen, W_OK) == -1)
    ERR_Aplicacion(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion",
		   "fichero \"%s\" no accesible para escritura", fichImagen);

/*--------------------------------------------------------------------
 | Se abre el fichero imagen de la Configuracion
 +--------------------------------------------------------------------*/
fdFBD = open(fichImagen, O_RDWR | O_EXCL);
if (fdFBD == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion", "open",
		 "fichero \"%s\" (para lectura/escritura))", fichImagen);
 
[TABLA>
{
	char bufElems[BUF_<TBL:NOMBRE>];
	Type<TBL:NOMBRE> *p<TBL:Nombre>;

/*--------------------------------------------------------------------
 | Se posiciona en la posicion  de la tabla <TBL:NOMBRE> en el fichero
 +--------------------------------------------------------------------*/
if (lseek(fdFBD, POS_<TBL:NOMBRE>, SEEK_SET) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion", "lseek",
		"fichero \"%s\" (posicion POS_<TBL:NOMBRE>)", fichImagen);

/*--------------------------------------------------------------------
 | Se leen todos los elementos de la tabla desde el fichero.
 +--------------------------------------------------------------------*/
if (read(fdFBD, bufElems, BUF_<TBL:NOMBRE>) != BUF_<TBL:NOMBRE>)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion", "read",
		 "fichero \"%s\" (BUF_<TBL:NOMBRE> bytes)", fichImagen);

/*--------------------------------------------------------------------
 | Se cuenta el numero de elementos ocupados que tiene el fichero y se
 | comprueba que el dimensionado es suficiente.
 +--------------------------------------------------------------------*/
pElem = bufElems;
*pNum<TBL:Nombre> = 0;
for (i = 0; i < MAX_<TBL:NOMBRE>; i++, pElem += LON_<TBL:NOMBRE>)
    if (ESTA_OCUPADO(pElem))
	(*pNum<TBL:Nombre>)++;

if (*pNum<TBL:Nombre> > *pMax<TBL:Nombre>)
    ERR_Aplicacion(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion",
    	"el numero de elementos %d de <TBL:NOMBRE> supera el dimensionado %d",
	*pNum<TBL:Nombre>, *pMax<TBL:Nombre>);

/*--------------------------------------------------------------------
 | Se extraen los registros ocupados y se inicializan las posiciones
 | de cada clave. Tambien se calculan la suma y resta de check-sum.
 +--------------------------------------------------------------------*/
indOcu = 0;
indLib = *pNum<TBL:Nombre>;
pElem  = bufElems;

p<TBL:Nombre> = (Type<TBL:NOMBRE> *) DIR_MEM(*pPos<TBL:Nombre>);
for (i = 0; i < *pMax<TBL:Nombre>; i++) {
    if (ESTA_OCUPADO(pElem)) {
	CalcSumaResta(pElem, LON_<TBL:NOMBRE>, 1,
		  	pSum<TBL:Nombre>, pRes<TBL:Nombre>);
	[+]_Dec<TBL:Nombre>(pElem, p<TBL:Nombre>);
	indAct = indOcu;
	indOcu++;
	}
    else {
	indAct = indLib;
	indLib++;
	}
[CLAVE>
    clv<CLA:Nombre><TBL:Nombre>[indAct] = POS_MEM(p<TBL:Nombre>);
<CLAVE]
    pElem += LON_<TBL:NOMBRE>;
    p<TBL:Nombre>++;
    }
}

/*--------------------------------------------------------------------
 | Se ordenan los array de posiciones de las claves de la tabla.
 +--------------------------------------------------------------------*/
Ord<TBL:Nombre>();

<TABLA]

/*--------------------------------------------------------------------
 | Se cierra el fichero imagen de la Configuracion.
 +--------------------------------------------------------------------*/
if (close(fdFBD) == -1)
    ERR_SistOper(ERR_FATAL, FUNC_BDT, "[+]: IniInformacion", "close",
		     "fichero \"%s\"", fichImagen);
fdFBD = -1;
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * CalcularMemoria
 *	Calcula el tamano de la memoria necesaria para la Configuracion
 *====================================================================*/
static void CalcularMemoria()
{
/*--------------------------------------------------------------------
 | Memoria para el numero de elementos de las tablas.
 +--------------------------------------------------------------------*/
lonMemoria  = sizeof(int)  * <BAS:numTbl> * 3;
lonMemoria += sizeof(int) * <BAS:numTbl> * 2;
[TABLA>

/*--------------------------------------------------------------------
 | Memoria para la/s clave/s  los elementos de la tabla <TBL:NOMBRE>
 +--------------------------------------------------------------------*/
[CLAVE>
lonMemoria += max<TBL:Nombre> * sizeof(int *) * <TBL:numCla>;
<CLAVE]
lonMemoria += max<TBL:Nombre> * TAM_<TBL:NOMBRE>;
<TABLA]
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * IniPunteros
 *	Inicializa los punteros de acceso a cada una de las zonas de
 *	la memoria:
 *		- posicion correspondiente con el fichero imagen.
 *		- arrays de acceso por clave.
 *		- numero de elementos.
 *		- informacion de la tablas.
 *    Parametros:
 *	iniValores: indicativo para la inicializacion de valores.
 *====================================================================*/
static void IniPunteros(int iniValores)
{
	char *pActual;

/*--------------------------------------------------------------------
 | Se inicializa pActual al comienzo de la zona de memoria de la base
 +--------------------------------------------------------------------*/
pActual = pMemoria;

[TABLA>
/*--------------------------------------------------------------------
 | Se inicializan los punteros de acceso a la tabla <TBL:NOMBRE>:
 |	pPos<TBL:Nombre>: punt. a la informacion de los elementos.
 |	pNum<TBL:Nombre>: punt. al numero de elementos.
[CLAVE>
 |	clv<CLA:Nombre><TBL:Nombre>: array de acceso por la clave <CLA:Nombre>
<CLAVE]
 +--------------------------------------------------------------------*/
pPos<TBL:Nombre> = (int *) pActual;
pActual += sizeof(int);
pNum<TBL:Nombre> = (int *) pActual;
pActual += sizeof(int);
pMax<TBL:Nombre> = (int *) pActual;
pActual += sizeof(int);
pSum<TBL:Nombre> = (int *) pActual;
pActual += sizeof(int);
pRes<TBL:Nombre> = (int *) pActual;
pActual += sizeof(int);

[CLAVE>
clv<CLA:Nombre><TBL:Nombre> = (int *) pActual;
pActual += (max<TBL:Nombre> * sizeof(int *));
<CLAVE]

if (iniValores) {
    *pPos<TBL:Nombre> = POS_MEM(pActual);
    *pNum<TBL:Nombre> = 0;
    *pMax<TBL:Nombre> = max<TBL:Nombre>;
    *pSum<TBL:Nombre> = 0L;
    *pRes<TBL:Nombre> = 0L;
    }
pActual += (max<TBL:Nombre> * TAM_<TBL:NOMBRE>);

<TABLA]
}

[TABLA>
/*========================= FUNCION PRIVADA =========================
 * Ord<TBL:Nombre>
 *	Ordena los punt. de acceso a la tabla <TBL:NOMBRE>, por:
[CLAVE>
 *		- <CLA:NOMBRE>
<CLAVE]
 *====================================================================*/
static void Ord<TBL:Nombre>()
{
/*--------------------------------------------------------------------
 | Ordena el array de acceso a la tabla <TBL:NOMBRE> por las claves:
[CLAVE>
 |	- <CLA:NOMBRE>
<CLAVE]
 +--------------------------------------------------------------------*/
[CLAVE>
qsort(clv<CLA:Nombre><TBL:Nombre>, *pNum<TBL:Nombre>,
      sizeof(int), (PF_COMPAR)CmpDes<CLA:Nombre><TBL:Nombre>);
<CLAVE]
}

/*========================= FUNCION PRIVADA =========================
 * Clave<TBL:Nombre>
 *	Devuelve el array de acceso correspondiente el codigo de
 *	una determinada clave de la tabla <TBL:NOMBRE>.
 *
 *    Parametros:
 *	codClave: codigo de la clave.
 *    Devuelve:
 *	el array de acceso de la clave: si el codigo es correcto.
 *	NULL: si el codigo es erroneo.
 *====================================================================*/
static int *Clave<TBL:Nombre>(const int codClave)
{
switch(codClave) {
[CLAVE>
    case CLV_<CLA:NOMBRE>_<TBL:NOMBRE>:
	return clv<CLA:Nombre><TBL:Nombre>;
<CLAVE]
    }
ERR_Aplicacion(ERR_NO_FATAL, FUNC_BDT, "[+]: Clave<TBL:Nombre>",
	"codigo de clave (%d) de la tabla <TBL:NOMBRE> erroneo", codClave);
return NULL;
}

[CLAVE>
/*========================= FUNCION PRIVADA =========================
 * CmpDes<CLA:Nombre><TBL:Nombre>
 *	Compara la clave <CLA:NOMBRE> de dos elementos de la tabla
 *	<TBL:NOMBRE> segun sus posiciones en la memoria.
 *    Parametros:
 *	pPosic1: punt. a la posicion del elemento 1 a comparar la clave.
 *	pPosic2: punt. a la posicion del elemento 2 a comparar la clave.
 *    Devuelve:
 *      num > 0: si la clave del pPosic1 es mayor que el del pPosic2.
 *      0:	 si la clave del pPosic1 es igual que el del pPosic2.
 *      num < 0: si la clave del pPosic1 es menor que el del pPosic2.
 *====================================================================*/
static int CmpDes<CLA:Nombre><TBL:Nombre>(const int *pPosic1, const int *pPosic2)
{
return Cmp<CLA:Nombre><TBL:Nombre>((Type<TBL:NOMBRE> *) DIR_MEM(*pPosic1),
			(Type<TBL:NOMBRE> *) DIR_MEM(*pPosic2));
}

/*========================= FUNCION PRIVADA =========================
 * Cmp<CLA:Nombre><TBL:Nombre>
 *	Compara la clave <CLA:NOMBRE> de dos elementos de la tabla
 *	<TBL:NOMBRE>.
 *    Parametros:
 *	p<TBL:Nombre>:  punt. al elemento 1 a comparar la clave.
 *	p<TBL:Nombre>2: punt. al elemento 2 a comparar la clave.
 *    Devuelve:
 *      num > 0: si la clave de p<TBL:Nombre> es mayor que p<TBL:Nombre>2.
 *      0:	 si la clave de p<TBL:Nombre> es igual que p<TBL:Nombre>2.
 *      num < 0: si la clave de p<TBL:Nombre> es menor que p<TBL:Nombre>2.
 *====================================================================*/
static int Cmp<CLA:Nombre><TBL:Nombre>(const Type<TBL:NOMBRE> *p<TBL:Nombre>,
				const Type<TBL:NOMBRE> *p<TBL:Nombre>2)
{
	int result;

[CAMPO CLAVE>
/*--------------------------------------------------------------------
 | Si el campo <CAM:NOMBRE> del elemento 1 y 2 es distinto, se devuelve
 | el resultado de la comparacion.
 +--------------------------------------------------------------------*/
if ((result = <CAM:cmpEst>) != 0) 
    return result;

<CAMPO CLAVE]
return 0;
}

<CLAVE]
<TABLA]

/*====================== PROCEDIMIENTO PRIVADO ======================
 * CalcSumaResta
 *	Dado un elemento de una tabla codificado, calcula el valor de
 *	la suma de los bytes, asi como la resta de estos por pares.
 *	Los valores suma/resta calculados se acumulan en los totales
 *	siendo sumados o restados segun el flag "sumar".
 *
 *    Parametros:
 *	pElemento: puntero al elemento a tratar.
 *	lonElem:   longitud en bytes del elemento.
 *	sumar:     flag para sumar o restar la suma/resta calculada.
 *	pSumTot:   puntero donde acumular la suma (segun el flag sumar)
 *	pResTot:   puntero donde acumular la resta (segun el flag sumar)
 *====================================================================*/
static void CalcSumaResta(char *pElemento, int lonElem, int sumar,
			  int *pSumTot, int *pResTot)
{
	int valByte;
	int sumParc;
	int resParc;

/*--------------------------------------------------------------------
 | Se inicializa la suma y resta parcial a 0 y al valor inicial.
 +--------------------------------------------------------------------*/
sumParc = 0;
resParc = 0;

/*--------------------------------------------------------------------
 | Se calcula la suma parcial y la resta parcial por pares de bytes.
 +--------------------------------------------------------------------*/
while(lonElem) {
    valByte  = (int) (0x00FF & *pElemento++);
    sumParc += valByte;
    resParc += (lonElem % 2) ? -(valByte) : valByte;
    lonElem--;
    }

/*--------------------------------------------------------------------
 | Se totaliza la suma/resta parcial sobre el total corespondiente
 | sumando/restado segun el flag "sumar".
 +--------------------------------------------------------------------*/
*pSumTot += (sumar)? sumParc : -(sumParc);
*pResTot += (sumar)? resParc : -(resParc);
}

/*========================= FUNCION PRIVADA =========================
 * BuscaElemento
 *	Busca un elemento por el algoritmo de busqueda binaria
 *
 *    Parametros:
 *	elemBuscar: buffer del elemento a buscar.
 *	accClave:   array de posiciones para acceso por clave.
 *	numElem:    numero de elementos de la tabla.
 *	FuncCompar: funcion de comparacion por la clave en cuestion.
 *    Devuelve:
 *	indice: indice (referido a puntClave) del elemento buscado.
 *	-1: si el elemento no existe.
 *====================================================================*/
static int BuscaElemento(void *elemBuscar, int *accClave, int numElem,
			 PF_COMPAR FuncCompar)
{
	int topeBajo;
	int topeAlto;
	int indice;
	int result;

/*--------------------------------------------------------------------
 | Se inicializa la franja de busqueda a la totalidad de elementos.
 +--------------------------------------------------------------------*/
topeBajo = 0;
topeAlto = numElem - 1;

/*--------------------------------------------------------------------
 | Se compara el elemento intermedio de la franja tal que si es:
 |  - IGUAL: elemento encontrado.
 |  - MAYOR: se toma la franja mitad superior (avanza topeBajo).
 |  - MENOR: se toma la franja mitad inferior (retrocede topeAlto).
 | Si se cruzan los indices, el elemento no existe.
 +--------------------------------------------------------------------*/
while (topeBajo <= topeAlto) {
    indice = (topeBajo + topeAlto) / 2;
    result = (*FuncCompar)(elemBuscar, DIR_MEM(accClave[indice]));
    if (result == 0)
	return indice;
    if (result > 0)
	topeBajo = indice + 1;
    else
	topeAlto = indice - 1;
    }
return -1;
}

/*====================== PROCEDIMIENTO PRIVADO ======================
 * PosicionLibre
 *	Deja libre una posicion (desplazamiento) en un array.
 *
 *    Parametros:
 *	posicion: posicion a dejar libre.
 *	array:    array de posiciones.
 *	numElem:  numero de elementos del array
 *====================================================================*/
static void PosicionLibre(int posicion, int *array, int numElem)
{
	int i;

/*--------------------------------------------------------------------
 | Se busca la posicion en el array
 +--------------------------------------------------------------------*/
for (i = 0; i < numElem; i++)
    if (array[i] == posicion)
	break;

/*--------------------------------------------------------------------
 | Elimina la posicion moviendo el bloque de posiciones y la pone al
 | final de dicho bloque.
 +--------------------------------------------------------------------*/
memmove(array + i, array + i + 1, (numElem - i - 1) * sizeof(int));
array[numElem - 1] = posicion;
}

/*========================= FUNCION PUBLICA =========================
 * [+]_NumRecords
 *      Informa del numero de registros que tiene la tabla.
 *
 *    Parametros:
 *      - tabla: identificador de la tabla a dimensionar.
 *    Devuelve:
 *       n: el numero de registros.
 *      -1: si la tabla no es correcta
 *====================================================================*/
int [+]_NumRecords(int tabla)
{
switch(tabla) {
[TABLA>
    case TBL_<TBL:NOMBRE>:
        return *pNum<TBL:Nombre>;
<TABLA]
    }
return -1;
}

